# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qtqCVIEtmQYUcRISQI9GT8U73RxAJtgP
"""

import numpy as np
import cv2
import math
import matplotlib.pyplot as plt
import random

MAX_ACTIONS = 4  # Maximum number of actions to be executed

def direction_index_to_angle(index):
    return index * 22.5

def generate_rectangle_corners(start, direction_index, length, thickness):
    angle = direction_index_to_angle(direction_index)
    x1, y1 = start
    radian = math.radians(angle)

    # Calculate P2
    x2 = x1 + length * math.cos(radian)
    y2 = y1 + length * math.sin(radian)

    # Calculate orthogonal vector for thickness
    v1 = np.array([x2 - x1, y2 - y1])
    v1_length = np.linalg.norm(v1)
    n = np.array([-v1[1], v1[0]]) / v1_length  # Normalized orthogonal vector

    # Calculate P3 and P4 using thickness
    x3 = x1 + n[0] * thickness
    y3 = y1 + n[1] * thickness
    x4 = x2 + (x3 - x1)
    y4 = y2 + (y3 - y1)

    return [(int(x1), int(y1)), (int(x2), int(y2)), (int(x4), int(y4)), (int(x3), int(y3))]

def draw_filled_rectangle(canvas, corners):
    pts = np.array(corners, np.int32)
    pts = pts.reshape((-1, 1, 2))

    # Determine the majority color within the rectangle
    mask = np.zeros(canvas.shape, dtype=np.uint8)
    cv2.fillPoly(mask, [pts], color=1)
    majority_color = 1 if np.sum(canvas[mask == 1]) < np.sum(mask) / 2 else 0

    # Fill the rectangle with the reverse color of the majority
    cv2.fillPoly(canvas, [pts], color=majority_color)

def calculate_allowed_actions(agent_position, canvas):
    allowed_actions = []
    directions = range(16)  # Indices 0 to 15
    for direction_index in directions:
        for length in range(4, 33, 4):  # Lengths from 4 to 32 in steps of 4
            new_x = agent_position[0] + int(length * math.cos(math.radians(direction_index_to_angle(direction_index))))
            new_y = agent_position[1] + int(length * math.sin(math.radians(direction_index_to_angle(direction_index))))
            if 0 <= new_x < 32 and 0 <= new_y < 32:  # Ensure within bounds
                allowed_actions.append(('move_empty', direction_index, length))
                for thickness in range(1, length):  # Thickness must be less than length
                    allowed_actions.append(('move_line', direction_index, length, thickness))
    print(f"Allowed actions for position {agent_position}: {allowed_actions}")  # Debugging
    return allowed_actions

def apply_actions(canvas, actions, start_position=(16, 16)):
    agent_position = start_position  # Start position
    for action in actions:
        action_type, direction_index, length, *params = action
        thickness = params[0] if params else 1
        if action_type == 'move_line':
            corners = generate_rectangle_corners(agent_position, direction_index, length, thickness)
            draw_filled_rectangle(canvas, corners)
        new_position = (
            agent_position[0] + int(length * math.cos(math.radians(direction_index_to_angle(direction_index)))),
            agent_position[1] + int(length * math.sin(math.radians(direction_index_to_angle(direction_index))))
        )
        agent_position = (
            max(0, min(new_position[0], 31)),  # Ensure within bounds
            max(0, min(new_position[1], 31))
        )
    return canvas, agent_position

# Initialize a black canvas
initial_canvas = np.zeros((32, 32), dtype=np.uint8)

# Predefined actions to draw some patterns (white pixels)
initial_actions = [
    ('move_line', 0, 10, 2),  # Example actions
    ('move_line', 4, 8, 3),
    ('move_empty', 4, 4, 1),
    ('move_line', 8, 12, 1)
]

# Apply initial actions to the canvas to create white pixels and get the new agent position
initial_canvas, initial_position = apply_actions(initial_canvas, initial_actions)
print(initial_position)
# Display the initial canvas with the pattern
plt.imshow(initial_canvas, cmap='gray')
plt.show()

class State:
    def __init__(self, canvas, agent_position, actions_taken=0):
        self.canvas = canvas
        self.agent_position = agent_position
        self.actions_taken = actions_taken

    def is_terminal(self):
        return self.actions_taken >= MAX_ACTIONS or np.sum(self.canvas) == 0  # Terminal if all pixels are black or max actions taken

    def reward(self):
        return -np.sum(self.canvas)  # Cost as the number of remaining white pixels

    def possible_actions(self):
        return calculate_allowed_actions(self.agent_position, self.canvas)

    def perform_action(self, action):
        action_type, direction_index, length, *params = action
        thickness = params[0] if params else 1
        new_position = (
            self.agent_position[0] + int(length * math.cos(math.radians(direction_index_to_angle(direction_index)))),
            self.agent_position[1] + int(length * math.sin(math.radians(direction_index_to_angle(direction_index))))
        )

        new_position = (
            max(0, min(new_position[0], 31)),  # Ensure within bounds
            max(0, min(new_position[1], 31))
        )

        new_canvas = np.copy(self.canvas)
        if action_type == 'move_line':
            corners = generate_rectangle_corners(self.agent_position, direction_index, length, thickness)
            draw_filled_rectangle(new_canvas, corners)

        return State(new_canvas, new_position, self.actions_taken + 1)

class Node:
    def __init__(self, state, parent=None):
        self.state = state
        self.parent = parent
        self.children = []
        self.visits = 0
        self.value = 0

    def is_fully_expanded(self):
        return len(self.children) == len(self.state.possible_actions())

    def best_child(self, exploration_value):
        choices_weights = [
            (child.value / child.visits) + exploration_value * math.sqrt((2 * math.log(self.visits) / child.visits))
            for child in self.children
        ]
        return self.children[choices_weights.index(max(choices_weights))]

    def expand(self):
        for action in self.state.possible_actions():
            if action not in [child.state.action for child in self.children]:
                new_state = self.state.perform_action(action)
                child_node = Node(new_state, parent=self)
                self.children.append(child_node)
                print(f"Expanded with action: {action}")  # Debugging
                return child_node
        print("No new actions to expand")  # Debugging
        return None

    def update(self, reward):
        self.visits += 1
        self.value += reward

class MCTS:
    def __init__(self, root_state, exploration_value=1.41):
        self.root = Node(root_state)
        self.exploration_value = exploration_value

    def search(self, iterations):
        for _ in range(iterations):
            node = self.select(self.root)
            reward = self.simulate(node)
            self.backpropagate(node, reward)

    def select(self, node):
        while not node.state.is_terminal() and node.is_fully_expanded():
            node = node.best_child(self.exploration_value)
        return node

    def simulate(self, node):
        current_state = node.state
        while not current_state.is_terminal():
            action = random.choice(current_state.possible_actions())
            current_state = current_state.perform_action(action)
        return current_state.reward()

    def backpropagate(self, node, reward):
        while node is not None:
            node.update(reward)
            node = node.parent

# Initialize the root state for MCTS with the starting position at the center (16, 16)
initial_state = State(initial_canvas, (16, 16))
mcts = MCTS(initial_state)

# Run the MCTS search
mcts.search(10000)  # Number of iterations for MCTS

# Get the best action sequence from the root
best_node = mcts.root.best_child(0)
best_actions = []
while best_node:
    best_actions.append(best_node.state)
    best_node = best_node.best_child(0) if best_node.children else None

# Apply the best action sequence to the canvas
final_canvas = initial_canvas.copy()
for state in best_actions:
    final_canvas = state.canvas

# Display the final canvas after applying the best action sequence
plt.imshow(final_canvas, cmap='gray')
plt.show()

from typing import Callable, Dict, List, Tuple, Union, Any, Optional
import heapq

# SimulationTime Class
class SimulationTime:
    def __init__(self, seconds: float = 0, minutes: int = 0, hours: int = 0, days: int = 0, months: int = 0):
        self.seconds = seconds
        self.minutes = minutes
        self.hours = hours
        self.days = days
        self.months = months

    def to_seconds(self) -> float:
        return (self.months * 30 * 24 * 3600) + (self.days * 24 * 3600) + (self.hours * 3600) + (self.minutes * 60) + self.seconds


# Support Class
class Support:
    def __init__(self, conditions: Dict[str, Any], necessary_conditions: Dict[str, bool]):
        self.conditions = conditions
        self.necessary_conditions = necessary_conditions

    def validate(self, content: Dict[str, Any]) -> bool:
        content_value = content.get('value')
        self.conditions['data_type'] = type(content_value).__name__

        type_map = {
            'int': int,
            'float': float,
            'str': str,
            'bool': bool,
            # Add other necessary types here
        }

        for key, condition in self.conditions.items():
            if key not in content:
                if self.necessary_conditions.get(key, True):
                    raise ValueError(f"Missing mandatory key: {key}")
                else:
                    print(f"Warning: Missing non-mandatory key: {key}")
                continue

            content_value = content[key]

            if key == 'data_type':
                expected_type = type_map.get(condition)
                if expected_type and not isinstance(content_value, expected_type):
                    message = f"Data type mismatch: expected {condition}, got {type(content_value).__name__}"
                    if self.necessary_conditions.get(key, True):
                        raise ValueError(message)
                    else:
                        print(f"Warning: {message}")
            elif isinstance(condition, list):
                if content_value not in condition:
                    message = f"Value {content_value} not in allowed list {condition}"
                    if self.necessary_conditions.get(key, True):
                        raise ValueError(message)
                    else:
                        print(f"Warning: {message}")

        return True

    def compare_supports(self, other: 'Support') -> bool:
        for key, condition in self.conditions.items():
            other_condition = other.conditions.get(key)
            if other_condition is None:
                continue
            if key == 'data_type' and condition != other_condition:
                return False
            if isinstance(condition, list) and any(item not in other_condition for item in condition):
                return False
        return True


# State Class
class State:
    def __init__(self, window_size: int):
        if window_size < 1:
            raise ValueError("Window size must be greater than 0")
        self.variables: Dict[str, Union[int, float, str]] = {}
        self.current_time: int = 0
        self.last_update_time: int = 0
        self.window_size: int = window_size
        self.past_states: List[Dict[str, Union[int, Dict[str, Union[int, float, str]]]]] = []

    def update_state(self, variable_name: str, value: Union[int, float, str], time: int):
        if time < self.current_time:
            raise ValueError("New time must be greater than or equal to the current time")
        self.variables[variable_name] = value
        self.last_update_time = self.current_time
        self.current_time = time
        self.past_states.append({
            'time': self.current_time,
            'state': self.variables.copy()
        })
        if len(self.past_states) > self.window_size:
            self.past_states.pop(0)

    def get_variables(self) -> Dict[str, Union[int, float, str]]:
        return self.variables

    def get_current_time(self) -> int:
        return self.current_time

    def get_last_update_time(self) -> int:
        return self.last_update_time

    def get_window_size(self) -> int:
        return self.window_size

    def get_past_states(self) -> List[Dict[str, Union[int, Dict[str, Union[int, float, str]]]]]:
        return self.past_states


# Port Class
class Port:
    def __init__(self, port_id: int, port_type: str, support: Optional[Support] = None):
        if port_type not in ['in', 'out']:
            raise ValueError("Port type must be either 'in' or 'out'")
        self.port_id: int = port_id
        self.support: Support = support if support else Support({}, {})
        self.type: str = port_type  # 'in' or 'out'
        self.connected_devices: List[Tuple[int, int]] = []

    def get_port_id(self) -> int:
        return self.port_id

    def get_support(self) -> Support:
        return self.support

    def get_type(self) -> str:
        return self.type

    def get_connected_devices(self) -> List[Tuple[int, int]]:
        return self.connected_devices

    def add_connected_device(self, agent_id: int, port_id: int):
        self.connected_devices.append((agent_id, port_id))

    def set_support(self, support: Support):
        self.support = support

    def validate_support(self, content: Dict[str, Any]) -> bool:
        return self.support.validate(content)

    def assign_support(self, message: 'Message'):
        self.support.conditions['data_type'] = type(message.content['value']).__name__
        message.set_support(self.support)


# Message Class
class Message:
    def __init__(self, sender_agent_id: int, sender_port_id: int, receiver_agent_id: int, receiver_port_id: int, content: Dict[str, Any], support: Support, receive_time: float):
        self.sender_agent_id: int = sender_agent_id
        self.sender_port_id: int = sender_port_id
        self.receiver_agent_id: int = receiver_agent_id
        self.receiver_port_id: int = receiver_port_id
        self.content: Dict[str, Any] = content  # A dict containing 'send_time', 'receive_time', 'value'
        self.support: Support = support
        self.receive_time: float = receive_time

    def set_support(self, support: Support):
        self.support = support


class Scheduler:
    def __init__(self, start_time: float):
        self.current_time = start_time
        self.event_queue: List[Tuple[float, int, Callable]] = []
        self.sequence = 0

    def schedule(self, action: Callable, time: float):
        print(f"Scheduling action at time {time}")
        heapq.heappush(self.event_queue, (time, self.sequence, action))
        self.sequence += 1

    def run(self, duration: float):
        end_time = self.current_time + duration
        while self.event_queue and self.event_queue[0][0] <= end_time:
            time, _, action = heapq.heappop(self.event_queue)
            print(f"Running action at time {time}")
            self.current_time = time
            action()
        self.current_time = end_time
        print(f"Simulation ended at time {self.current_time}")





# Agent Class
class Agent:
    def __init__(self, agent_id: int, state: State, ports: List[Port], handler: Callable[['Agent', State, List[Port], List[Message]], None]):
        self.agent_id: int = agent_id
        self.state: State = state
        self.ports: List[Port] = ports
        self.message_queue: List[Message] = []
        self.handler: Callable[['Agent', State, List[Port], List[Message]], None] = handler
        self.scheduler: Union[None, Scheduler] = None
        self.agents: List[Agent] = []  # Placeholder for the list of agents

    def handle(self):
        if not callable(self.handler):
            raise ValueError("Handler is not a callable function")
        self.handler(self, self.state, self.ports, self.message_queue)
        self.message_queue.clear()  # Clear the message queue after handling

    def add_connected_device(self, foreign_agent_id: int, foreign_port_id: int, local_port_id: int):
        for port in self.ports:
            if port.get_port_id() == local_port_id:
                port.add_connected_device(foreign_agent_id, foreign_port_id)
                return
        raise ValueError(f"Local port ID {local_port_id} not found in agent {self.agent_id}")

    def get_agent_id(self) -> int:
        return self.agent_id

    def get_state(self) -> State:
        return self.state

    def get_ports(self) -> List[Port]:
        return self.ports

    def get_message_queue(self) -> List[Message]:
        return self.message_queue

    def set_scheduler(self, scheduler: Scheduler):
        self.scheduler = scheduler

    def schedule_execution(self, time: float):
        if self.scheduler:
            self.scheduler.schedule(self.handle, time)

    def send_message(self, receiver_agent_id: int, receiver_port_id: int, content: Dict[str, Any], delay: float):
        receiver_agent = self.get_agent_by_id(receiver_agent_id)
        if receiver_agent:
            for port in self.ports:
                if port.get_type() == 'out':
                    support = port.get_support()
                    receive_time = self.scheduler.current_time + delay
                    message = Message(self.agent_id, port.get_port_id(), receiver_agent_id, receiver_port_id, content, support, receive_time)
                    port.assign_support(message)
                    self.scheduler.schedule(lambda: receiver_agent.receive_message(message), receive_time)

    def receive_message(self, message: Message):
        for port in self.ports:
            if port.get_type() == 'in' and port.get_port_id() == message.receiver_port_id:
                try:
                    port.validate_support(message.content)
                except ValueError as e:
                    print(f"Message validation failed at port {port.get_port_id()}: {e}")
                else:
                    self.message_queue.append(message)
                    self.handle()

    def get_agent_by_id(self, agent_id: int) -> Optional['Agent']:
        for agent in self.agents:
            if agent.get_agent_id() == agent_id:
                return agent
        return None



# AgentSystem Class
class AgentSystem:
    def __init__(self, start_time: Union[float, SimulationTime] = 0):
        self.agents: List[Agent] = []
        self.connections: Dict[int, List[Tuple[int, int, int]]] = {}
        self.scheduler: Scheduler = Scheduler(start_time if isinstance(start_time, float) else start_time.to_seconds())
        self.time: float = start_time if isinstance(start_time, float) else start_time.to_seconds()

    def add_agent(self, agent: Agent):
        agent_id = len(self.agents)
        agent.agent_id = agent_id
        agent.set_scheduler(self.scheduler)
        agent.agents = self.agents  # Assign the agents list to the agent for get_agent_by_id
        self.agents.append(agent)
        self.scheduler.schedule(agent.handle, self.time)

    def add_connection(self, agent1_id: int, port1_index: int, agent2_id: int, port2_index: int):
        if not (0 <= agent1_id < len(self.agents) and 0 <= agent2_id < len(self.agents)):
            raise ValueError("Invalid agent ID")
        agent1 = self.agents[agent1_id]
        agent2 = self.agents[agent2_id]

        if not (0 <= port1_index < len(agent1.ports) and 0 <= port2_index < len(agent2.ports)):
            raise ValueError("Invalid port index")

        port1 = agent1.ports[port1_index]
        port2 = agent2.ports[port2_index]

        try:
            port1.get_support().compare_supports(port2.get_support())
        except ValueError as e:
            raise ValueError(f"Support validation failed: {e}")

        connection = ((agent1_id, port1_index), (agent2_id, port2_index))
        if agent1_id in self.connections:
            self.connections[agent1_id].append((port1_index, agent2_id, port2_index))
        else:
            self.connections[agent1_id] = [(port1_index, agent2_id, port2_index)]

        agent1.add_connected_device(agent2_id, port2_index, port1_index)
        agent2.add_connected_device(agent1_id, port1_index, port2_index)

    def delete_connection(self, agent1_id: int, port1_index: int, agent2_id: int, port2_index: int):
        if agent1_id in self.connections:
            self.connections[agent1_id] = [
                conn for conn in self.connections[agent1_id] if conn != (port1_index, agent2_id, port2_index)
            ]

    def check_connections(self):
        for agent1_id, connections in self.connections.items():
            agent1 = self.agents[agent1_id]
            for port1_index, agent2_id, port2_index in connections:
                agent2 = self.agents[agent2_id]
                if not (0 <= port1_index < len(agent1.ports) and 0 <= port2_index < len(agent2.ports)):
                    raise ValueError("Invalid port index in connection")

    def initialize_system(self):
        for agent in self.agents:
            agent.schedule_execution(self.time)

    def run_simulation(self, duration: Union[float, SimulationTime]):
        if isinstance(duration, SimulationTime):
            duration = duration.to_seconds()
        self.initialize_system()
        self.scheduler.run(duration)


def example_handler(agent: Agent, state: State, ports: List[Port], message_queue: List[Message]):
    # Define how the agent handles its logic here
    for message in message_queue:
        # Process each message
        pass
    # Schedule next execution
    state.update_state('sample', state.get_variables().get('sample', 0) + 1, state.get_current_time() + 1)
    agent.schedule_execution(state.get_current_time() + 3600)  # Schedule next execution in 1 hour


def environment_handler(agent: Agent, state: State, ports: List[Port], message_queue: List[Message]):
    # Retrieve constants from state
    wall_area = state.get_variables().get('wall_area')
    wall_thickness = state.get_variables().get('wall_thickness')
    thermal_conductivity = state.get_variables().get('thermal_conductivity')
    air_capacity = state.get_variables().get('air_capacity')
    air_density = state.get_variables().get('air_density')
    room_volume = state.get_variables().get('room_volume')
    time_step = state.get_variables().get('time_step')
    heater_surface_area = state.get_variables().get('heater_surface_area')
    convective_heat_transfer_coefficient = state.get_variables().get('convective_heat_transfer_coefficient')

    # Get the current heater power and temperature
    heater_power = state.get_variables().get('heater_power', 0.0)
    current_temp = state.get_variables().get('current_temp', 22.0)
    temperatures = state.get_variables().get('temperatures', [])
    heating_powers = state.get_variables().get('heating_powers', [])
    scheduler = agent.scheduler
    current_time = scheduler.current_time

    # Determine the current hour to get the outside temperature
    hour = int(current_time // 3600) % 24
    outside_temp = state.get_variables().get('outside_temperatures')[hour]

    # Calculate temperature change
    heater_temp = current_temp + (heater_power / (convective_heat_transfer_coefficient * heater_surface_area))  # Assume heater temperature is proportional to power
    Q_conv = convective_heat_transfer_coefficient * heater_surface_area * (heater_temp - current_temp) * time_step
    Q_loss = (thermal_conductivity * wall_area * (current_temp - outside_temp) / wall_thickness) * time_step
    total_heat = Q_conv - Q_loss
    temperature_change = total_heat / (air_density * room_volume * air_capacity)
    new_temp = current_temp + temperature_change

    print(f"[Environment] Time: {current_time}, Heater Power: {heater_power}, New Temp: {new_temp}")

    # Update state variables
    temperatures.append(new_temp)
    heating_powers.append(heater_power)
    state.update_state('current_temp', new_temp, int(current_time))
    state.update_state('temperatures', temperatures, int(current_time))
    state.update_state('heating_powers', heating_powers, int(current_time))

    for message in message_queue:
        if 'request_temperature' in message.content:
            agent.send_message(message.sender_agent_id, message.sender_port_id, {'value': new_temp, 'send_time': current_time}, delay=1)
        elif 'set_heater_power' in message.content:
            print(f"[Environment] Setting heater power to {message.content['value']}")
            state.update_state('heater_power', message.content['value'], int(current_time))

    # Schedule the next temperature update
    agent.scheduler.schedule(agent.handle, current_time + time_step)














### Controller Agent Handler

def controller_handler(agent: Agent, state: State, ports: List[Port], message_queue: List[Message]):
    # Retrieve PID constants from state
    Kp = state.get_variables().get('Kp')
    Ki = state.get_variables().get('Ki')
    Kd = state.get_variables().get('Kd')
    desired_temp = state.get_variables().get('desired_temp')

    # Get PID state variables
    integral = state.get_variables().get('integral', 0.0)
    previous_error = state.get_variables().get('previous_error', 0.0)
    current_time = agent.scheduler.current_time

    for message in message_queue:
        if 'value' in message.content:
            current_temp = message.content['value']
            error = desired_temp - current_temp
            integral += error
            derivative = error - previous_error
            heater_power = max(0, min(150, Kp * error + Ki * integral + Kd * derivative))  # Clamped to the range [0, 150]

            print(f"[Controller] Time: {current_time}, Temp: {current_temp}, Error: {error}, Integral: {integral}, Derivative: {derivative}, Heater Power: {heater_power}")

            state.update_state('integral', integral, int(current_time))
            state.update_state('previous_error', error, int(current_time))

            agent.send_message(agent.agent_id, 1, {'value': heater_power, 'set_heater_power': True}, delay=1)  # Ensure it sends to the correct port
            agent.scheduler.schedule(agent.handle, current_time + 3600)  # Schedule next temperature request in 1 hour
        elif 'request_temperature' in message.content:
            agent.send_message(agent.agent_id, 1, {'request_temperature': True}, delay=1)
            agent.scheduler.schedule(agent.handle, current_time + 3600)  # Schedule response handling in 1 hour










# Outside temperature profile (24 hours)
# Outside temperature profile (24 hours)
# Outside temperature profile (24 hours)
# Outside temperature profile (24 hours)
outside_temperatures = [10, 8, 5, 3, 2, 0, -1, -3, -5, -7, -9, -10, -9, -8, -5, -3, -1, 0, 2, 5, 7, 9, 10, 8]

# Initialize the simulation
simulation_time = SimulationTime(seconds=0)
agent_system = AgentSystem(simulation_time)

# Initialize state for environment agent
env_state = State(window_size=10)
env_state.update_state('heater_power', 0.0, 0)
env_state.update_state('current_temp', 22.0, 0)
env_state.update_state('outside_temperatures', outside_temperatures, 0)
env_state.update_state('temperatures', [], 0)
env_state.update_state('heating_powers', [], 0)
env_state.update_state('wall_area', 120, 0)
env_state.update_state('wall_thickness', 0.3, 0)
env_state.update_state('thermal_conductivity', 0.04, 0)
env_state.update_state('air_capacity', 1005, 0)
env_state.update_state('air_density', 1.225, 0)
env_state.update_state('room_volume', 300, 0)
env_state.update_state('time_step', 3600, 0)
env_state.update_state('heater_surface_area', 0.5, 0)  # Heater surface area in m²
env_state.update_state('convective_heat_transfer_coefficient', 10, 0)  # Example value in W/m²·K

# Initialize state for controller agent
controller_state = State(window_size=10)
controller_state.update_state('Kp', 1.0, 0)
controller_state.update_state('Ki', 0.1, 0)
controller_state.update_state('Kd', 0.05, 0)
controller_state.update_state('desired_temp', 22.0, 0)
controller_state.update_state('integral', 0.0, 0)
controller_state.update_state('previous_error', 0.0, 0)

# Define ports
env_ports = [Port(port_id=0, port_type='in'), Port(port_id=1, port_type='out')]
controller_ports = [Port(port_id=0, port_type='in'), Port(port_id=1, port_type='out')]

# Create agents
env_agent = Agent(agent_id=0, state=env_state, ports=env_ports, handler=environment_handler)
controller_agent = Agent(agent_id=1, state=controller_state, ports=controller_ports, handler=controller_handler)

# Add agents to the system
agent_system.add_agent(env_agent)
agent_system.add_agent(controller_agent)

# Establish communication between controller and environment
agent_system.add_connection(controller_agent.get_agent_id(), 1, env_agent.get_agent_id(), 0)
agent_system.add_connection(env_agent.get_agent_id(), 1, controller_agent.get_agent_id(), 0)

# Schedule initial temperature request
controller_agent.scheduler.schedule(controller_agent.handle, 1)  # Schedule the first temperature request in 1 second
env_agent.scheduler.schedule(env_agent.handle, 3600)  # Schedule the first environment update in 1 hour

# Initialize the system and run the simulation for 24 hours
agent_system.run_simulation(SimulationTime(hours=24))

# Retrieve the temperature and heating power data for visualization
temperatures = env_state.get_variables().get('temperatures')
heating_powers = env_state.get_variables().get('heating_powers')
print(temperatures)
print(heating_powers)

import matplotlib.pyplot as plt

# Parameters
outside_temperatures = [10, 8, 5, 3, 2, 0, -1, -3, -5, -7, -9, -10, -9, -8, -5, -3, -1, 0, 2, 5, 7, 9, 10, 8]
room_volume = 300  # m³
heater_surface_area = 0.5  # m²
wall_area = 120  # m²
wall_thickness = 0.3  # m
thermal_conductivity = 0.04  # W/m·K
air_capacity = 1005  # J/kg·K
air_density = 1.225  # kg/m³
convective_heat_transfer_coefficient = 10  # W/m²·K
desired_temp = 22.0  # °C

# PID constants
Kp = 1.0
Ki = 0.1
Kd = 0.05

# Initial conditions
current_temp = 15.0  # °C
heater_power = 0.0  # W
integral = 0.0
previous_error = 0.0

# Simulation data storage
temperatures = [current_temp]
heater_powers = [heater_power]

# Simulation loop for 24 hours, with a time step of 1 minute (1440 minutes in 24 hours)
for minute in range(1, 1441):
    # Get the outside temperature for the current hour
    hour = minute // 60
    outside_temp = outside_temperatures[hour % 24]

    # Calculate temperature change
    heater_temp = current_temp + (heater_power / (convective_heat_transfer_coefficient * heater_surface_area))
    Q_conv = convective_heat_transfer_coefficient * heater_surface_area * (heater_temp - current_temp) * 60
    Q_loss = (thermal_conductivity * wall_area * (current_temp - outside_temp) / wall_thickness) * 60
    total_heat = Q_conv - Q_loss
    temperature_change = total_heat / (air_density * room_volume * air_capacity)
    current_temp += temperature_change

    # Store the temperature
    temperatures.append(current_temp)

    # PID control
    error = desired_temp - current_temp
    integral += error * 60  # Integral term with respect to time in seconds
    derivative = (error - previous_error) / 60  # Derivative term with respect to time in seconds
    heater_power = max(0, min(150, Kp * error + Ki * integral + Kd * derivative))  # Clamp power to [0, 150]
    previous_error = error

    # Store the heater power
    heater_powers.append(heater_power)

    # Debugging output
    if minute % 60 == 0:  # Print every hour
        print(f"Hour {hour}: Temp = {current_temp:.2f}°C, Heater Power = {heater_power:.2f}W")

# Plotting the results
plt.figure(figsize=(12, 6))
plt.plot([t / 60 for t in range(len(temperatures))], temperatures, label='Room Temperature (°C)')
plt.plot([t / 60 for t in range(len(heater_powers))], heater_powers, label='Heater Power (W)')
plt.xlabel('Time (hours)')
plt.ylabel('Value')
plt.legend()
plt.title('Room Temperature and Heater Power Over Time')
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

class Room:
    def __init__(self, outdoor_temps, initial_temp, target_temp, heat_capacity, heat_transfer_coefficient, room_area, Kp, Ki, Kd):
        self.outdoor_temps = outdoor_temps  # List of hourly outdoor temperatures
        self.current_temp = initial_temp + 273.15  # Convert to Kelvin
        self.target_temp = target_temp + 273.15  # Convert to Kelvin
        self.heat_capacity = heat_capacity
        self.k = heat_transfer_coefficient * room_area * 8  # Adjusting for the room's surface area and multiplying by 8
        self.current_time = 0  # Start at the first hour
        self.temp_history = [self.current_temp]  # To track temperature over time
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.integral = 0
        self.previous_error = 0

    def update_temperature(self, hours):
        for _ in range(hours):
            if self.current_time >= len(self.outdoor_temps):
                break
            T_out = self.outdoor_temps[self.current_time] + 273.15  # Convert to Kelvin
            T_in = self.current_temp

            # Calculate the error
            error = self.target_temp - T_in

            # Update integral and derivative terms
            self.integral += error
            derivative = error - self.previous_error

            # PID controller output (heater power)
            P_heater = self.Kp * error + self.Ki * self.integral + self.Kd * derivative

            # Ensure heater power is non-negative
            P_heater = max(P_heater, 0)

            # Calculate temperature change due to heater
            dT_heater = P_heater / self.heat_capacity

            # Calculate temperature change due to environment
            dT_env = -self.k * (T_in - T_out) / self.heat_capacity

            # Update indoor temperature
            self.current_temp += dT_heater + dT_env
            self.temp_history.append(self.current_temp)

            # Update previous error and time
            self.previous_error = error
            self.current_time += 1

    def set_target_temp(self, target_temp):
        self.target_temp = target_temp + 273.15  # Convert to Kelvin

# Example usage:
# Outdoor temperatures for a month (simplified example with 24 hourly values repeated)
outdoor_temps = np.array([10, 8, 5, 3, 2, 0, -1, -3, -5, -7, -9, -10, -9, -8, -5, -3, -1, 0, 2, 5, 7, 9, 10, 8] * 30)
initial_temp = 15  # Initial indoor temperature in degrees Celsius
target_temp = 25  # Target indoor temperature in degrees Celsius
heat_capacity = 307031.25  # Heat capacity in J/K
heat_transfer_coefficient = 1.6  # Heat transfer coefficient in W/m^2°C
room_area = 100  # Room surface area in m^2

# PID controller gains
Kp = 10000
Ki = 1
Kd = 100

room = Room(outdoor_temps, initial_temp, target_temp, heat_capacity, heat_transfer_coefficient, room_area, Kp, Ki, Kd)

# Update the temperature for the next 24 hours
room.update_temperature(24 * 30)  # Simulate for a month

# Plot the indoor temperature over time
plt.figure(figsize=(12, 6))
plt.plot(np.array(room.temp_history) - 273.15, label='Indoor Temperature (°C)')
plt.plot(outdoor_temps[:len(room.temp_history)], label='Outdoor Temperature (°C)', linestyle='--')
plt.xlabel('Time (hours)')
plt.ylabel('Temperature (°C)')
plt.title('Indoor and Outdoor Temperature Over Time with PID Control')
plt.legend()
plt.grid(True)
plt.show()